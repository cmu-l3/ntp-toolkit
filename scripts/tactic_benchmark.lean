import TrainingData.Frontend
import Mathlib.Control.Basic
import Mathlib.Lean.Expr.Basic
import Mathlib.Tactic.Common
import Mathlib.Tactic.ToExpr
import Aesop
import Lean.Util.Trace
import Duper
import QuerySMT.QuerySMT
import Cli

open Lean Core Elab IO Meta Term Tactic -- All the monads!

set_option autoImplicit true

/--
Compile the designated module, and run a monadic function with each new `ConstantInfo`,
with the `Environment` as it was *before* the command which created that declaration.

(Internal declarations according to `Name.isBlackListed` are skipped.)
-/
def runAtDecls (mod : Name) (tac : ConstantInfo → MetaM (Option α)) :
    MLList IO (ConstantInfo × α) := do
  let fileName := (← findLean mod).toString
  let steps := compileModule' mod
  let targets := steps.bind fun c => (MLList.ofList c.diff).map fun i => (c, i)

  targets.filterMapM fun (cmd, ci) => do
    for m in cmd.msgs do IO.eprintln (bombEmoji ++ (← m.data.toString))
    unless cmd.msgs.isEmpty do
      throw <| IO.userError s!"Unexpected messages in: {mod} during elaboration of {cmd.stx}"

    let options := ({} : KVMap).insert `maxHeartbeats (.ofNat 20000)
    let ctx := { fileName, options, fileMap := default }
    let state := { env := cmd.before }
    -- From `IO` to `CoreM`:
    Prod.fst <$> (CoreM.toIO · ctx state) do
      if ← ci.name.isBlackListed then
        pure none
      else
        -- From `CoreM` to `MetaM`:
        MetaM.run' (ctx := {}) (s := {}) do
          match ← tac ci with
          | some r => pure (ci, r)
          | none => pure none

inductive ResultType
| failure
| subgoals
| notDefEq
| success
deriving Repr, BEq

instance : ToString ResultType where
  toString := fun
  | .failure => "failure"
  | .subgoals => "subgoals"
  | .notDefEq => "notDefEq"
  | .success => "success"

structure Result where
  type : ResultType
  seconds : Float
  heartbeats : Nat

def withSeconds [Monad m] [MonadLiftT BaseIO m] (act : m α) : m (α × Float) := do
  let start ← IO.monoNanosNow
  let a ← act
  let stop ← IO.monoNanosNow
  return (a, (stop - start).toFloat / 1000000000)

/--
Compile the designated module, select declarations satisfying a predicate,
and run a tactic on the type of each declaration.
-/
def runTacticAtDecls (mod : Name) (decls : ConstantInfo → CoreM Bool) (tac : TacticM Unit) :
    MLList IO (ConstantInfo × Result) := do
  runAtDecls mod fun ci => do
    if ! (← decls ci) then return none
    let g ← mkFreshExprMVar ci.type
    -- From `MetaM` to `TermElabM`
    let ((gs, seconds), heartbeats) ← withHeartbeats <| withSeconds <|
      try? <| TermElabM.run' do
        -- From `TermElabM` to `TacticM`!
        Tactic.run g.mvarId! tac
    let type : ResultType ← match gs with
    | none => pure .failure
    | some (_ :: _) => pure .subgoals
    | some [] =>
      match ci.value? with
      | none => pure .success
      | some v =>
        if ← isProp ci.type then
          pure .success
        else
        match ← try? (isDefEq g v) with
        | none
          -- In this case we should perhaps return an "uncertain" value.
          -- The problem is that `v` may contain constants generated by the simplifier
          -- during elaboration of the original proof,
          -- and which aren't in the current environment, so we can't really compare `g` and `v`
        | some false => pure .notDefEq
        | some true => pure .success
    return some ⟨type, seconds, heartbeats⟩

def useAesop : TacticM Unit := do evalTactic (← `(tactic| aesop))
def useExact? : TacticM Unit := do evalTactic (← `(tactic| exact?))
def useRfl : TacticM Unit := do evalTactic (← `(tactic| intros; rfl))
def useSimpAll : TacticM Unit := do evalTactic (← `(tactic| intros; simp_all))
def useOmega : TacticM Unit := do evalTactic (← `(tactic| intros; omega))
def useDuper : TacticM Unit := do evalTactic (← `(tactic| duper [*]))
def useQuerySMT : TacticM Unit := do evalTactic (← `(tactic| querySMT))

open Cli System

def tacticBenchmarkFromModule (module : ModuleName) (tac : TacticM Unit) : IO UInt32 := do
  searchPathRef.set compile_time_search_path%
  let result := runTacticAtDecls module (fun _ => pure true) tac
  IO.println s!"{module}"
  for (ci, ⟨type, seconds, heartbeats⟩) in result do
    IO.println <| (if type == .success then checkEmoji else crossEmoji) ++ " " ++ ci.name.toString ++
      s!" ({seconds}s) ({heartbeats} heartbeats)"
  return 0

def tacticBenchmarkMain (args : Cli.Parsed) : IO UInt32 := do
  let module := args.positionalArg! "module" |>.as! ModuleName
  let tac ←
    if args.hasFlag "duper" then pure useDuper else
    if args.hasFlag "querySMT" then pure useQuerySMT else
    if args.hasFlag "aesop" then pure useAesop else
    if args.hasFlag "exact" then pure useExact? else
    if args.hasFlag "rfl" then pure useRfl else
    if args.hasFlag "simp_all" then pure useSimpAll else
    if args.hasFlag "omega" then pure useOmega else
    throw <| IO.userError "Specify a tactic, e.g. `--aesop`"
  tacticBenchmarkFromModule module tac

/-- Setting up command line options and help text for `lake exe tactic_benchmark`. -/
def tactic_benchmark : Cmd := `[Cli|
  tactic_benchmark VIA tacticBenchmarkMain; ["0.0.1"]
  "Run a customisable tactic at all declarations in a file."

  FLAGS:
    "aesop";       "Use `aesop`."
    "exact";       "Use `exact?`."
    "rfl";         "Use `intros; rfl`."
    "simp_all";    "Use `intros; simp_all`."
    "omega";       "Use `intros; omega`."
    "duper";       "Use `duper [*]`."
    "querySMT";    "Use `querySMT`."

  ARGS:
    module : ModuleName; "Lean module to compile and export InfoTrees."
]

/-- `lake exe tactic_benchmark` -/
def main (args : List String) : IO UInt32 :=
  tactic_benchmark.validate args

-- See `scripts/tactic_benchmark.sh` for a script to run this on all of Mathlib.

-- #eval tacticBenchmarkFromModule `temp useQuerySMT
-- Note: `tacticBenchmarkFromModule` requires that the tactic we want be imported in the module
/- **TODO** Figure out heartbeat issue (querySMT can solve list_eq_self and zero_eq_zero) plenty quickly,
   but `tacticBenchmarkFromModule` says it doesn't solve the former and takes significantly longer to
   solve the latter -/
/- Interestingly, `useDuper` doesn't seem to (obviously) run into the same issue as `useQuerySMT`.
   I think this is because Duper has precompiledModules enabled whereas QuerySMT doesn't, but that's
   something to investigate further -/
